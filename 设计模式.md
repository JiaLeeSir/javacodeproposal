# 设计模式之禅 学习


## 1：6大设计原则



### 1.1 单一职责原则

单一职责原则有以下好处：

- 类的复杂性降低，实现什么职责都有清晰明确的定义
- 可读性提高，复杂性降低
- 可维护性提高，可读性提高
- 变更引起的风险降低

### 1.2 里氏替换原则

**继承的优点：**

- 代码共享，减少创建类的工作量。每个子类都拥有父类的方法和属性
- 提高代码的重用性
- 子类可以形似父类，但又异于父类。
- 提高代码的可扩展性
- 提高产品或项目的开放性

**继承的缺点：**

- 继承是侵入性的

- 降低代码灵活性

- 增加了耦合性

  



 	C++采用多继承的规则，一个子类可以继承多个父类。从整体上，利大于弊，怎么能让利的因素发挥到最大的作用，同时减少弊的麻烦，**解决办法是引入里氏替换原则**。

```java
/*	通俗的讲，只要父类能出现的地方，子类就能出现，而且替换子类也不会产生任何错误异常，或者可能根本就不需要知道是父类还是子类。但是返回来就不行了，有子类出现的地方，父类未必就能适应。
*/
```



### 1.3 依赖倒置原则

依赖的3种写法

​	1 构造函数传递依赖对象

​	2 setter方法传递依赖对象

​	3 接口声明依赖对象



### 1.4 接口隔离原则

​	把一个臃肿的接口更变为两个独立的接口所依赖的原则就是接口隔离原则。通过分散定义多个接口，可以预防未来变更的扩散。



### 1.5 迪米特法则

​	也叫做最少知识原则。通俗的说，一个类应该对自己需要耦合或者调用的类知道的最小。





### 1.6 开闭原则





## 2：23种设计模式



### 2.1 单例模式



#### 定义

> 确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例

#### 单例模式优点

- 由于内存中只有一个实例，减少了内存开支。特别是一个对象频繁地创建、销毁，且创建销毁时性能又无法优化，单例模式优势很明显。
- 减少了系统性能开销(当一个对象的产生需要比较多的资源时，如读取配置文件、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决(在JavaEE中采用单例模式需要注意JVM垃圾回收机制))
- 单例模式可以避免对资源的多重占用。
- 单例模式可以在系统设置全局的访问点，优化和共享资源访问。

#### 单例模式的缺点

- 单例模式一般没有接口，扩展困难，如果要扩展，除了修改代码基本上没有第二种途径。

```java
#dd//单例模式为什不能增加接口？
   //因为对接口对单例模式没有任何意义，它要求“自行实例化”，并提供单一实例，接口或者抽象类不可能被实例化
```

- 单例模式对测试不利。
- 单例模式和单一职责原则冲突。`一个类应该只实现一个逻辑，而不关心它是否是单例，是不是要单例取决于环境，单例模式把“要单例”和业务融合在一个类中。`

#### 单例的使用场景

​	在一个系统中，要求类有且仅有一个对象，如果出现多个对象会有“不良反应”，可以采用单例。

- 要求生成唯一序号的环境
- 在整个项目中需要一个共享访问点或共享数据。(WEB页面的计数器，不用每次刷新都记录到数据库中，使用单例模式保持计数器的值，并确保是线程安全的)
- 创建一个对象需要消耗的资源过多`如访问IO和数据库等资源`
- 需要大量定义的静态常量和静态方法(工具方法)的环境中，可以采用单例(也可以直接声明为static)



#### 单例模式的注意事项



```java
---------------------饿汉单例(线程安全)----------------
public class Singleton {
	private static final Singleton singleton = new Singleton();
	// 限制产生多个
	private Singleton() {
	}
	public static Singleton getSingleton() {
		return singleton;
	}
	public static void doSomething() {
	}
}
---------------------懒汉单例(线程不安全)--------------
public class Singleto {
	private static Singleto singleto = null;
	// 限制产生多个对象
	private Singleto() {
	}
	
	public static Singleto getSingleto(){
		if(singleto==null){
			return new Singleto();
		}
		return singleto;
	}
} 
   

```

​	高并发的情况下。懒汉模式存在线程安全问题。

​	如果一个对象执行到了`singleto= new Singleto();` ，但是还没获取到对象(对象初始化需要时间)。第二个线程也执行`singleto==null` ，那么 也会产生一个新对象，因此产生了2个对象。

​	解决线程安全可以使用`synchronized` ，但不是最优秀的单例模式。

​	其次，需要考虑对象复制。对象默认是不可被复制的，若实现了`Cloneable`  接口，通过复制创造一个新对象，对象复制不是通过调用类的构造函数。因此即使使用私有构造函数，对象仍然可以被复制。`解决办法是单例类不要实现Cloneable` 。



#### 单例中允许存在2个对象

```java
public class Emperor {
	// 定义最多能产生的实例数量
	private static int maxNumOfEmperor = 2;
	// 每个皇帝的名字
	private static ArrayList<String> nameList = new ArrayList<String>();
	// 容纳皇帝的实例
	private static ArrayList<Emperor> emperorList = new ArrayList<Emperor>();
	// 当前皇帝的序号
	private static int countNumOfEmperor = 0;

	// 产出所有对象
	static {
		for (int i = 0; i < maxNumOfEmperor; i++) {
			emperorList.add(new Emperor("皇帝" + (i + 1)));
		}
	}

	public static Emperor getInstance() {
		// 随机
		countNumOfEmperor = new Random().nextInt(maxNumOfEmperor);
		return emperorList.get(countNumOfEmperor);
	}

	private Emperor() {

	}

	// 传入名称，建立一个对象
	private Emperor(String name) {
		nameList.add(name);
	}

	public static void say() {
		System.out.println(nameList.get(countNumOfEmperor));
	}
	public static void main(String[] args) {
		int minSnum=5;
		for (int i = 0; i <minSnum; i++) {
			Emperor instance = Emperor.getInstance();
			System.out.print("第"+(i+1)+"个大臣 拜见的是");
			instance.say();
		}
		/*
		 * 第1个大臣 拜见的是皇帝1 
		 * 第2个大臣 拜见的是皇帝1 
		 * 第3个大臣 拜见的是皇帝2 
		 * 第4个大臣 拜见的是皇帝1 
		 * 第5个大臣 拜见的是皇帝2
		 */

	}
}
```







## 3：设计模式PK





## 4：设计模式混编



